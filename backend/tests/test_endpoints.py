import pytest\nimport json\nfrom datetime import datetime, timedelta\nfrom unittest.mock import Mock, patch, MagicMock\nfrom fastapi.testclient import TestClient\nfrom fastapi import HTTPException\n\nfrom app.main import (\n    ForecastInterval,\n    Forecast,\n    SalesPoint,\n    ForecastRequest,\n    Staff,\n    OptimizeRequest,\n    Schedule,\n)\n\n\n@patch('app.main.datetime')\ndef test_health(mock_datetime, client: TestClient):\n    mock_now = Mock()\n    mock_now.now.return_value.isoformat.return_value = '2024-01-01T12:00:00'\n    mock_datetime.now.return_value = mock_now\n    \n    response = client.get('/health')\n    assert response.status_code == 200\n    assert response.json() == {'status': 'healthy', 'timestamp': '2024-01-01T12:00:00'}\n\n\nclass TestForecastJson:\n    @patch('app.main.pd')\n    @patch('app.main.Prophet')\n    def test_forecast_json_happy(self, mock_prophet, mock_pd, client: TestClient):\n        # Mock Prophet\n        mock_model = Mock()\n        mock_model.fit = Mock()\n        mock_model.make_future_dataframe.return_value = Mock()  # pd.DataFrame\n        mock_model.predict.return_value = Mock()\n        mock_forecast_df = Mock()\n        mock_forecast_df.tail.return_value.iterrows.return_value = [\n            (0, Mock(**{\n                'ds': datetime(2024,1,1), 'yhat': 10.0, 'yhat_lower': 8.0, 'yhat_upper': 12.0\n            }))\n        ]\n        mock_model.predict.return_value = mock_forecast_df\n        mock_prophet.return_value = mock_model\n        \n        # Mock pd.DataFrame\n        mock_df = Mock()\n        mock_pd.DataFrame.return_value = mock_df\n        \n        history = [SalesPoint(ds=\"2024-01-01\", y=100.0) for _ in range(20)]\n        response = client.post('/forecast-json', json={'history': [h.dict() for h in history]})\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert 'intervals' in data\n        assert len(data['intervals']) >= 1\n        interval = data['intervals'][0]\n        assert interval['demand'] == 10.0  # from mock\n\n    @patch('app.main.pd')\n    @patch('app.main.Prophet')\n    def test_forecast_json_insufficient_data(self, mock_prophet, mock_pd, client: TestClient):\n        history = [SalesPoint(ds=\"2024-01-01\", y=100.0) for _ in range(10)]  # <14\n        response = client.post('/forecast-json', json={'history': [h.dict() for h in history]})\n        assert response.status_code == 400\n        assert '14 data points' in response.json()['detail']\n\n\nclass TestForecastFile:\n    @patch('app.main.pd')\n    @patch('app.main.io.BytesIO')\n    @patch('app.main.Prophet')\n    def test_forecast_file_csv_ds_y(self, mock_prophet, mock_bytesio, mock_pd, client: TestClient):\n        mock_csv_content = Mock(read_csv=Mock(return_value=Mock(**{\n            'columns': ['ds', 'y'], 'shape': (20, 2)\n        })))\n        mock_pd.read_csv.return_value = mock_csv_content\n        \n        # Mock Prophet as above... similar to json\n        mock_model = Mock()\n        # ... (abbrev for brevity, similar mocks)\n        mock_prophet.return_value = mock_model\n        \n        csv_data = 'ds,y\\n2024-01-01,100\\n2024-01-02,110'\n        files = {'file': ('test.csv', csv_data.encode(), 'text/csv')}\n        response = client.post('/forecast', files=files)\n        assert response.status_code == 200\n\n    def test_forecast_file_invalid_format(self, client: TestClient):\n        files = {'file': ('test.txt', b'invalid', 'text/plain')}\n        response = client.post('/forecast', files=files)\n        assert response.status_code == 400\n        assert 'CSV file required' in response.json()['detail']\n\n    def test_forecast_file_no_columns(self, client: TestClient):\n        csv_data = 'no_ds,no_y'\n        files = {'file': ('test.csv', csv_data.encode(), 'text/csv')}\n        response = client.post('/forecast', files=files)\n        assert response.status_code == 400\n\n    def test_forecast_file_legacy_sales(self, client: TestClient):\n        # Tests legacy mock path\n        csv_data = 'sales\\n100\\n110'\n        files = {'file': ('test.csv', csv_data.encode(), 'text/csv')}\n        response = client.post('/forecast', files=files)\n        assert response.status_code == 200\n        data = response.json()\n        assert len(data['intervals']) == 168\n\n\nclass TestOptimizeJson:\n    @patch('app.main.cp_model.CpModel')\n    @patch('app.main.cp_model.CpSolver')\n    def test_optimize_json_happy(self, mock_solver_cls, mock_model_cls, client: TestClient):\n        # Mock model and solver\n        mock_solver = Mock()\n        mock_solver.Solve.return_value = cp_model.OPTIMAL\n        mock_solver.Value.return_value = 1\n        mock_solver.ObjectiveValue.return_value = 1000.0\n        mock_solver_cls.return_value = mock_solver\n        \n        mock_model = Mock()\n        mock_model.NewBoolVar.return_value = 1  # bool var\n        mock_model_cls.return_value = mock_model\n        \n        forecast = [ForecastInterval(time=\"2024-01-01T00:00:00\", demand=5.0, confidence_low=4.0, confidence_high=6.0) for _ in range(168)]\n        staff = [Staff(id=\"1\", name=\"John\", wage=25.0)]\n        req = {'forecast': [f.dict() for f in forecast], 'staff': [s.dict() for s in staff]}\n        \n        response = client.post('/optimize-json', json=req)\n        assert response.status_code == 200\n        data = response.json()\n        assert data['total_cost'] == 1000.0  # mocked\n        assert len(data['shifts']) > 0\n\n    def test_optimize_no_staff(self, client: TestClient):\n        req = {\n            'forecast': [ForecastInterval(time=\"2024-01-01T00:00:00\", demand=5.0, confidence_low=4.0, confidence_high=6.0).dict()],\n            'staff': []\n        }\n        response = client.post('/optimize-json', json=req)\n        assert response.status_code == 200\n        assert response.json() == {'shifts': [], 'total_cost': 0.0}\n\n    @patch('app.main.cp_model.CpSolver')\n    def test_optimize_no_feasible(self, mock_solver_cls, client: TestClient):\n        mock_solver = Mock()\n        mock_solver.Solve.return_value = cp_model.INFEASIBLE\n        mock_solver_cls.return_value = mock_solver\n        \n        forecast = [ForecastInterval(time=\"2024-01-01T00:00:00\", demand=100.0, confidence_low=90.0, confidence_high=110.0)] * 168  # high demand\n        staff = [Staff(id=\"1\", name=\"John\", wage=25.0)]  # too few\n        req = {'forecast': [f.dict() for f in forecast[:168]], 'staff': [s.dict() for s in staff]}\n        response = client.post('/optimize-json', json=req)\n        assert response.status_code == 500\n        assert 'No feasible schedule' in response.json()['detail']\n\n\n# Note: /optimize file endpoint uses legacy mock, test similarly but with files\n# Mock pd.read_csv for staff_file\n