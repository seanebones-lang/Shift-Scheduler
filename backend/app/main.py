from typing import List\nfrom pydantic import BaseModel\nfrom fastapi import FastAPI, UploadFile, File, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nimport pandas as pd\nimport io\nfrom datetime import datetime, timedelta\nfrom prophet import Prophet\nfrom ortools.sat.python import cp_model\n\napp = FastAPI(title=\"ShiftAI Scheduler API\")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\nclass ForecastInterval(BaseModel):\n    time: str\n    demand: float\n    confidence_low: float\n    confidence_high: float\n\nclass Forecast(BaseModel):\n    intervals: List[ForecastInterval]\n\nclass SalesPoint(BaseModel):\n    ds: str\n    y: float\n\nclass ForecastRequest(BaseModel):\n    history: List[SalesPoint]\n\nclass Staff(BaseModel):\n    id: str\n    name: str\n    wage: float\n    skill: str = \"general\"\n\nclass OptimizeRequest(BaseModel):\n    forecast: List[ForecastInterval]\n    staff: List[Staff]\n\nclass Shift(BaseModel):\n    staff_id: str\n    name: str\n    start: str\n    end: str\n    cost: float\n\nclass Schedule(BaseModel):\n    shifts: List[Shift]\n    total_cost: float\n\n@app.get(\"/health\")\ndef health():\n    return {\"status\": \"healthy\", \"timestamp\": datetime.now().isoformat()}\n\n@app.post(\"/forecast\", response_model=Forecast)\nasync def forecast_sales(file: UploadFile = File(...)):\n    if not file.filename.endswith('.csv'):\n        raise HTTPException(status_code=400, detail=\"CSV file required\")\n    content = await file.read()\n    try:\n        df = pd.read_csv(io.BytesIO(content))\n        if 'ds' in df.columns and 'y' in df.columns and len(df) >= 14:  # min data for Prophet\n            df['ds'] = pd.to_datetime(df['ds'])\n            df = df[['ds', 'y']].rename(columns={'y': 'y'})\n            m = Prophet(interval_width=0.8, daily_seasonality=True, weekly_seasonality=True, yearly_seasonality=False)\n            m.fit(df)\n            future = m.make_future_dataframe(periods=168, freq='H')\n            forecast_df = m.predict(future)\n            intervals = []\n            for _, row in forecast_df.tail(168).iterrows():\n                dt = row['ds']\n                demand = float(row['yhat'])\n                low = float(row['yhat_lower'])\n                high = float(row['yhat_upper'])\n                if demand > 0:  # filter negative\n                    intervals.append(ForecastInterval(\n                        time=dt.isoformat(),\n                        demand=round(demand, 2),\n                        confidence_low=round(low, 2),\n                        confidence_high=round(high, 2)\n                    ))\n            return Forecast(intervals=intervals)\n        elif 'sales' in df.columns:\n            # Legacy mock\n            base_demand = df['sales'].mean()\n            intervals = []\n            for i in range(168):\n                dt = datetime.now() + timedelta(hours=i)\n                demand = max(0, base_demand * (1.5 if 8 <= dt.hour < 18 else 0.7))\n                low, high = demand * 0.8, demand * 1.2\n                intervals.append(ForecastInterval(time=dt.isoformat(), demand=round(demand, 2), confidence_low=round(low, 2), confidence_high=round(high, 2)))\n            return Forecast(intervals=intervals)\n        else:\n            raise HTTPException(status_code=400, detail=\"CSV must have 'ds','y' or 'sales' column\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post(\"/forecast-json\", response_model=Forecast)\ndef forecast_sales_json(req: ForecastRequest):\n    try:\n        df = pd.DataFrame(req.history)\n        if len(df) < 14:\n            raise HTTPException(status_code=400, detail=\"Need at least 14 data points for forecasting\")\n        df['ds'] = pd.to_datetime(df['ds'])\n        df = df[['ds', 'y']]\n        m = Prophet(interval_width=0.8, daily_seasonality=True, weekly_seasonality=True)\n        m.fit(df)\n        future = m.make_future_dataframe(periods=168, freq='H')\n        forecast_df = m.predict(future)\n        intervals = []\n        for _, row in forecast_df.tail(168).iterrows():\n            dt = row['ds']\n            demand = float(row['yhat'])\n            low = float(row['yhat_lower'])\n            high = float(row['yhat_upper'])\n            if demand > 0:\n                intervals.append(ForecastInterval(\n                    time=dt.isoformat(),\n                    demand=round(demand, 2),\n                    confidence_low=round(low, 2),\n                    confidence_high=round(high, 2)\n                ))\n        return Forecast(intervals=intervals)\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post(\"/optimize\", response_model=Schedule)\nasync def optimize_shifts(forecast_file: UploadFile = File(...), staff_file: UploadFile = File(...)):\n    # Legacy mock\n    s_content = await staff_file.read()\n    staff_df = pd.read_csv(io.BytesIO(s_content))\n    shifts = []\n    total_cost = 0\n    for _, row in staff_df.iterrows():\n        start = datetime.now().isoformat()\n        end = (datetime.now() + timedelta(hours=8)).isoformat()\n        cost = row['wage'] * 8\n        shifts.append(Shift(staff_id=str(row['id']), name=row['name'], start=start, end=end, cost=float(cost)))\n        total_cost += float(cost)\n    return Schedule(shifts=shifts, total_cost=round(total_cost, 2))\n\n@app.post(\"/optimize-json\", response_model=Schedule)\ndef optimize_shifts_json(req: OptimizeRequest):\n    try:\n        demands = [i.demand for i in req.forecast[:168]]  # hourly demand 7d\n        num_staff = len(req.staff)\n        if num_staff == 0:\n            return Schedule(shifts=[], total_cost=0.0)\n\n        # Define 7 days x 3 shifts/day = 21 shifts\n        num_days = 7\n        shifts_per_day = 3\n        num_shifts = num_days * shifts_per_day\n        shift_hours = 8\n        max_shifts_per_staff = 5\n\n        # Compute needed staff per shift: avg demand in shift hours\n        needed = []\n        for day in range(num_days):\n            for s in range(shifts_per_day):\n                shift_start_h = s * 8\n                shift_demands = []\n                for h in range(shift_hours):\n                    hour_idx = day * 24 + shift_start_h + h\n                    if hour_idx < 168:\n                        shift_demands.append(demands[hour_idx])\n                avg_demand = sum(shift_demands) / len(shift_demands) if shift_demands else 0\n                needed.append(max(1, round(avg_demand / 1.0)))  # assume 1 staff covers 1 unit/hr\n\n        # OR-Tools CP-SAT\n        model = cp_model.CpModel()\n        x = {}\n        for i in range(num_staff):\n            for j in range(num_shifts):\n                x[(i, j)] = model.NewBoolVar(f'x_{i}_{j}')\n\n        # Each staff max shifts\n        for i in range(num_staff):\n            model.Add(sum(x[(i, j)] for j in range(num_shifts)) <= max_shifts_per_staff)\n\n        # Each shift covered\n        for j in range(num_shifts):\n            model.Add(sum(x[(i, j)] for i in range(num_staff)) >= needed[j])\n\n        # Objective: min total cost (wage * shift_hours)\n        obj = sum(req.staff[i].wage * shift_hours * x[(i, j)] for i in range(num_staff) for j in range(num_shifts))\n        model.Minimize(obj)\n\n        solver = cp_model.CpSolver()\n        status = solver.Solve(model)\n\n        if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n            shifts = []\n            total_cost = 0.0\n            base_time = datetime.now()\n            for j in range(num_shifts):\n                for i in range(num_staff):\n                    if solver.Value(x[(i, j)]) == 1:\n                        start_dt = base_time + timedelta(days=j // shifts_per_day, hours=(j % shifts_per_day)*8)\n                        end_dt = start_dt + timedelta(hours=shift_hours)\n                        cost = req.staff[i].wage * shift_hours\n                        shifts.append(Shift(\n                            staff_id=req.staff[i].id,\n                            name=req.staff[i].name,\n                            start=start_dt.isoformat(),\n                            end=end_dt.isoformat(),\n                            cost=cost\n                        ))\n                        total_cost += cost\n            return Schedule(shifts=shifts, total_cost=round(float(solver.ObjectiveValue()), 2))\n        else:\n            raise HTTPException(status_code=500, detail=\"No feasible schedule found\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\"app.main:app\", host=\"0.0.0.0\", port=8000, reload=True)\n